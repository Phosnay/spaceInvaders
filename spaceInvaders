import pygame as pg, sys                # sys = module qui permet d'interagir avec Python (sys.exit())
from pygame import mixer
from classes.classButton import Button
from classes.classPlayer import Player
from fonctions.ennemis import fillEnemyGroup, directionOfEnemies, detectCollision
from fonctions.missiles import creationMissile
from fonctions.vaisseau import displayHeart, fillHeartGroup

pg.init()   # sert à initialiser tous les modules de Pygame (display, time, surface, mixer (mais peut échouer silencieusement), event, key, mouse, font, )

################# Initialisation des sons Pygame ######################
# ----- pas besoin de mettre pg. devant chaque mixer car mixer a été importé de pygame
mixer.init(frequency=44100, size=-16, channels=2, buffer=512)   # Forçage de l’initialisation du module audio, avec réglages précis pour être sûr que le module audio marche
# mixer.music.load("sounds/player_shoot.wav")                   # lit directement depuis le fichier (ne charge pas tout en mémoire) une seule musique peut être jouée à la fois : musique longue
sound_shooting = mixer.Sound("sounds/player_shoot.wav")         # les fichiers sont chargés entièrement en mémoire et on peut en jouer plusieurs simultanément : bruitage court
optionVolume = 0.4                                              # 40% du volume 
sound_shooting.set_volume(optionVolume)                         # volume entre 0.0 et 1.0

################# Constantes #########################################
WIDTH, HEIGHT, FPS = 800, 800, 60       # affectation multiple pour 3 variables: largeur et hauteur de l'écran, FPS: Frames Per Second
BG = (24,26,32); WCOLOR = (200,80,80)   # le point virgule permet de mettre 2 instructions sur 1 ligne, 2 variables tuple RGB
SIZE, SPEED = 36, 220                   # taille des images, vitesse
SCROLL_SPEED = 60                       # vitesse du scroll (qtt de pixels par seconde)
ENEMYSPACE_X = 10                       # espacement entre les rangés des ennemis
ENEMYSTART_X = (WIDTH - ((10 * SIZE) + (9 * ENEMYSPACE_X))) // 2  # positionnement du premier ennemi pour que la ligne soit centrée

################# Variables ####################################################
screen = pg.display.set_mode((WIDTH, HEIGHT))           # display=gère l'affichage, set_mode=une fenêtre graphique
clock = pg.time.Clock()                                 # time.Clock=horloge interne
font = pg.font.SysFont("Arial", 24, True)               # police pour affichage texte
overlay = pg.Surface(screen.get_size(), pg.SRCALPHA)    # Crée une surface où l'on pourra gérer la transparente. remplacé (WIDTH, HEIGHT) par screen.get_size()
running = True

missilesVaisseau = pg.sprite.Group()    # stockage des missiles du vaisseau
missilesEnemies = pg.sprite.Group()     # stockage des missiles des ennemis
playerGroup = pg.sprite.GroupSingle()   # stockage du vaisseau

score = 0                   # initialisation du score
pv_joueur = 3               # Initialisation des pv (joueur)
damagePlayer = 1              # points perdus lors d'une collision
damageEnemy = 1               # points perdus lors d'une collision
menu_state = "main"         # état du menu général
game_paused = False         # Pour mettre en pause le jeu (ici false = pas de pause)

textScore = font.render(f"Score : {score}", True, (255, 255, 255))                          # crée une surface "texte" pour le score
textPause = font.render("\"ESPACE\"  : mettre en pause", True, (255, 255, 255))             # crée une surface "texte" pour indiquer comment mettre en pause, petit rappel : \ permet d'annuler le prochain charactère spécial (ici pour avoir des guillemets)
textVolume = font.render(f"Volume : {int(optionVolume * 100)}%", True, (255, 255, 255))
gameover_img = pg.image.load("graph/gameover_img.png").convert_alpha()
gameover_img = pg.transform.scale(gameover_img, (200,100))

############################## image des points de vie du vaisseau #############################
emptyHeart = pg.image.load("graph/emptyheart.png").convert_alpha()
emptyHeart = pg.transform.scale(emptyHeart, (50, 50))

############################## Création du background #############################
bg_img = pg.image.load("graph/scrollCropped.png").convert_alpha()   # chargement d'une image
bg_img = pg.transform.scale(bg_img, (WIDTH, HEIGHT))                # impose une taille à l'image, celle de la fenêtre
bg_height = bg_img.get_height()                                     # récupère la hauteur originale de l'image en pixels
bg_y = 0

############################## Création du vaisseau ###############################
player_img = pg.image.load("graph/vaisseau01.png").convert_alpha()          # chargement d'une image, en gardant la transparence
player_img = pg.transform.scale(player_img, (SIZE, SIZE))
player = Player(WIDTH//2 - SIZE//2, HEIGHT//1.1 - SIZE//2, player_img, pv_joueur)
playerGroup.add(player)

############################## Création du menu ##################################
resume_img = pg.image.load("graph/button_resume.png").convert_alpha()
options_img = pg.image.load("graph/button_options.png").convert_alpha()
quit_img = pg.image.load("graph/button_quit.png").convert_alpha()
video_img = pg.image.load("graph/button_video.png").convert_alpha()
audio_img = pg.image.load("graph/button_audio.png").convert_alpha()
keys_img = pg.image.load("graph/button_keys.png").convert_alpha()
back_img = pg.image.load("graph/button_back.png").convert_alpha()
plus_img = pg.image.load("graph/button_increase.png").convert_alpha()
plus_img = pg.transform.scale(plus_img, (50, 50))
minus_img = pg.image.load("graph/button_decrease.png").convert_alpha()
minus_img = pg.transform.scale(minus_img, (50, 50))
# sound_img = pg.image.load("graph/sound.png").convert_alpha()
# attention, ne pas mettre les boutons aux mêmes coordonnées dinon le clic de la souris actionne aussi le bouton qu'elle affiche
resume_button = Button(100, 125, resume_img, 1)
options_button = Button(100, 250, options_img, 1)
quit_button = Button(100, 375, quit_img, 1)
audio_button = Button(300, 250, audio_img, 1)
video_button = Button(300, 125, video_img, 1)
keys_button = Button(300, 375, keys_img, 1)
back_button = Button(500, 600, back_img, 1)
plus_button = Button(500, 500, plus_img, 1)
minus_button = Button(300, 500, minus_img, 1)


############################## création automatique des tirs du vaisseau  ##################################
# Ajoute dans la file d’événements un événement de type MISSILE_EVENT toutes les secondes.
MISSILE_EVENT = pg.USEREVENT + 1                # pg.USERVENT : correspont à un nombre fixe que Pygame connait. MISSILE_EVENT aura son propre identifiant numérique
pg.time.set_timer(MISSILE_EVENT, 1000)          # pg.time.set_timer : fonction de Pygame qui déclenche régulièrement (1000=toutes les secondes) un événement dans la file des événements (pg.event.get()).

############################## création des ennemis ##################################
enemyGroup = fillEnemyGroup(6, 10, WIDTH, SIZE) # liste contenant tous les ennemis 
heartGroup = fillHeartGroup(4)

########################################################################################################################
########################################################################################################################
############################## Boucle principale ##################################
while running:
    dt = clock.tick(FPS) / 1000.0               # dt = temps écoulé entre 2 frames, /1000.0 convertit les millisecondes en secondes

    #--- évènements ------------------------------------------------------------
    for e in pg.event.get():
        if e.type == pg.QUIT:                   # On verifie si on quitte le jeu
            running = False

        if not game_paused:
            # recherche de l'évènement : MISSILE_EVENT
            if e.type == MISSILE_EVENT:
                nouvMissile = creationMissile((player.rect.centerx - 4), (player.rect.top - 10), 1, SIZE, "vaisseau")   # Creation d'un missile au dessus du vaisseau
                missilesVaisseau.add(nouvMissile)
                sound_shooting.play()                
            # recherche de l'évènement : touche appuyée
            if e.type == pg.KEYDOWN:
                # si la touche "espace" est appuyée
                if e.key == pg.K_SPACE:
                    game_paused = True
    
    #--- affichage de la page du jeu-------------------------------------------------------------
    screen.blit(bg_img, (0, 0))         # affiche l'image de fond sur la fenêtre graphique aux coordonées (0, 0)        
    heartGroup.draw(screen)             # dessine les coeurs
    enemyGroup.draw(screen)             # dessine tous les ennemis
    missilesVaisseau.draw(screen)       # dessine tous les missiles du vaisseau
    # TODO : missilesEnemies.draw(screen)   # dessine tous les missiles des ennemis
    textScore = font.render(f"Score : {score}", True, (255, 255, 255))                          # crée une surface "texte" pour le score
    screen.blit(textScore, (650, 10))   # affiche le score en haut à droite
    screen.blit(textPause, (250, 10))   # affiche le texte de pause en haut
    playerGroup.draw(screen)            # dessine le vaisseau
    displayHeart(heartGroup, pv_joueur, emptyHeart)    # dessine les points de vie du vaisseau

    #--- affichage du game-over par dessus la page du jeu-------------------------------------------------------------
    if pv_joueur <= 0:
        game_paused = True
        overlay.fill((0, 0, 0, 160))           # remplit la surface overlay avec une couleur semi-transparente. 
        screen.blit(overlay, (0, 0))
        screen.blit(gameover_img, (300,300))

    #--- affichage du menu par dessus la page du jeu-------------------------------------------------------------
    if game_paused and pv_joueur > 0:
        # Quand game_paused == True, la partie overlay.blit est exécutée, donc la surface transparente apparaît.
        overlay.fill((0, 0, 0, 160))           # remplit la surface overlay avec une couleur semi-transparente. 
        screen.blit(overlay, (0, 0))

        if menu_state == "main":                # si menu principal est actif (lorsqu'on appuit sur la barre d'espace)
            if resume_button.draw(screen):      # affichage du bouton : reprendre le jeu
                game_paused = False             
            elif options_button.draw(screen):     # affichage du bouton : options 
                menu_state = "options"          # pour passer au menu "option"
            elif quit_button.draw(screen):        # affichage du bouton : quitter le jeu
                running = False                 # On arrete la boucle principale

        elif menu_state == "options":             # Verification de si option à été cliqué
            if video_button.draw(screen):
                menu_state = "video"
            elif audio_button.draw(screen):
                menu_state = "audio"
            elif keys_button.draw(screen):
                menu_state = "keys"
            elif back_button.draw(screen):
                menu_state = "main"

        elif menu_state == "video":               # Verification de si video à été cliqué
            if back_button.draw(screen):
                # TODO : 
                menu_options = "options"

        elif menu_state == "audio":               # Verification de si audio à été cliqué
            screen.blit(textVolume, (350, 400))
            if minus_button.draw(screen):
                optionVolume -= 0.1
                screen.blit(textVolume, (350, 400))
                if optionVolume < 0.0:
                    optionVolume = 0.0
                sound_shooting.set_volume(optionVolume) 
                textVolume = font.render(f"Volume : {int(optionVolume * 100)}%", True, (255, 255, 255))
            elif plus_button.draw(screen):
                optionVolume += 0.1
                screen.blit(textVolume, (350, 400))
                if optionVolume > 1.0:
                    optionVolume = 1.0
                sound_shooting.set_volume(optionVolume)
                textVolume = font.render(f"Volume : {int(optionVolume * 100)}%", True, (255, 255, 255))
            elif back_button.draw(screen):
                menu_state = "options"
        
        elif menu_state == "keys":                 # Verification de si keys à été cliqué
            if back_button.draw(screen):
                menu_state = "options"
        
    #--- actions du joueur-------------------------------------------------------------
    if not game_paused:
        # Quand game_paused == False, la partie overlay.blit n’est pas exécutée, donc la surface transparente disparaît.
        #--- déplacements ----------------------------------------
        player.update(screen)                       # déplacement du vaisseau
        missilesVaisseau.update()                   # déplacement de tous les missiles du vaisseau
        enemyGroup.update()                         # déplacement de tous les ennemis
        directionOfEnemies(enemyGroup, WIDTH, SIZE) # direction des déplacements des ennemis

        # TODO : déplacement de tous les missiles des ennemis
        
        # -------- création d'un missile quand on appuie sur une touche
        # TODO : si telle touche est appuyée alors:
            # missilesVaisseau.add(creationMissile(player.centerx - 5, player.top - 10, 1, int(SIZE / 10), "vaisseau"))

        # Collision entre les  missiles du vaisseau et des ennemis
        score += detectCollision(missilesVaisseau, enemyGroup, score, damageEnemy)
        # Collision entre le vaisseau et les ennemis
        pv_joueur -= detectCollision(enemyGroup, playerGroup, pv_joueur, damagePlayer)
        # TODO : Collision entre les missiles des ennemis et le vaisseau

    # double buffering :
    # pygame dessine tout le contenu sur un écran « hors écran » (back buffer),
    # il appelle pg.display.flip() pour basculer ce buffer vers l’écran visible (front buffer),
    # tout ce qu'il a dessiné devient visible à l’écran en une seule opération.
    pg.display.flip()


 #   pg.display.update()
pg.quit(); sys.exit()



####################### code en attente ou abandonné pour l'instant ##################################

#--- Défillement du background vers le bas ---
# bg_y += SCROLL_SPEED * dt                       # à chaque frame y augmente
# if bg_y >= bg_height:                           # quand y vaut la valeur de la hauteur de l'image du fond
#     bg_y = 0                                    # y repart à 0 : boucle infinie
# screen.blit(bg_img, (0, bg_y))                  # colle l'image sur la fenêtre graphique aux coordonées (x,y)        
# screen.blit(bg_img, (0, bg_y - bg_height))      # colle l'image juste au-dessous de la première




