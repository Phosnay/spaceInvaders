import pygame as pg, sys                # sys = module qui permet d'interagir avec Python (sys.exit())
import random as rdm
from pygame import mixer
from classes.classBlock import Block            # ou import classBlock 
from classes.classButton import Button
from fonctions.vaisseau import move_and_collide, missilesPlayer, pv_vaisseau
from fonctions.ennemis import fillEnemyGroup, directionOfEnemies, detectCollision
from fonctions.missiles import creationMissile
from classes.classPlayer import Player
################# variables constantes #####################
WIDTH, HEIGHT, FPS = 800, 800, 60       # affectation multiple pour 3 variables: largeur et hauteur de l'écran, FPS: Frames Per Second
BG = (24,26,32); WCOLOR = (200,80,80)   # le point virgule permet de mettre 2 instructions sur 1 ligne, 2 variables tuple RGB
SIZE, SPEED = 36, 220                   # taille des images, vitesse
SCROLL_SPEED = 60                       # vitesse du scroll (qtt de pixels par seconde)
ENEMYSPACE_X= 10                        # espacement entre les rangés des ennemis
ENEMYSTART_X = (WIDTH - ((10 * SIZE) + (9 * ENEMYSPACE_X))) // 2  # positionnement du premier ennemi pour que la ligne soit centrée

################# initialisation des modules Pygame ######################
pg.init()
screen = pg.display.set_mode((WIDTH, HEIGHT))   # display=gère l'affichage, set_mode=une fenêtre graphique
clock = pg.time.Clock()                         # time.Clock=horloge interne
score = 0                                       # initialisation du score
pv_joueur = 1                                   # Initialisation des pv (joueur)
menu_state = "main"                             # état du menu (base)
missilesVaisseau = pg.sprite.Group()            # stockage des missiles du vaisseau
missilesEnemies = pg.sprite.Group()             # stockage des missiles des ennemis
game_paused = False                             # Pour pauser le jeu (ici false = pas de pause)
# -------- Optionnel : créer un événement pour tirer automatiquement
# ------------ Chaque seconde, un évènement est créé dans pg.event.get()
MISSILE_EVENT = pg.USEREVENT + 1        # pg.USERVENT : correspont à un nombre fixe que Pygame connait. MISSILE_EVENT aura son propre identifiant numérique
pg.time.set_timer(MISSILE_EVENT, 1000)  # pg.time.set_timer : fonction de Pygame qui déclenche régulièrement un événement dans la file des événements (pg.event.get()).
                                        # Ajoute dans la file d’événements un événement de type MISSILE_EVENT toutes les secondes.

################# initialisation des sons Pygame ######################
mixer.init()
mixer.music.load("sounds/player_shoot.wav")
optionVolume = 0.5                           # volume entre 0.0 et 1.0
mixer.music.set_volume(optionVolume)

############################## image du background ##################################
bg_img = pg.image.load("graph/scrollCropped.png").convert_alpha()    # chargement d'une image
bg_img = pg.transform.scale(bg_img, (WIDTH, HEIGHT))    # impose une taille à l'image, celle de la fenêtre
bg_height = bg_img.get_height()                         # récupère la hauteur originale de l'image en pixels
bg_y = 0
gameover_img = pg.image.load("graph/gameover_img.png").convert_alpha()
gameover_img = pg.transform.scale(gameover_img, (WIDTH, HEIGHT))
############################## image du vaisseau ##################################
#player = pg.Rect(WIDTH//2 - SIZE//2, HEIGHT//1.1 - SIZE//2, SIZE, SIZE)     # rectangle (x, y, largeur, hauteur) au centre de la fenêtre
player_img = pg.image.load("graph/vaisseau01.png").convert_alpha()          # chargement d'une image, en gardant la transparence
player_img = pg.transform.scale(player_img, (SIZE, SIZE))
image = player_img
player = Player(WIDTH//2 - SIZE//2, HEIGHT//1.1 - SIZE//2, image, pv_joueur)
playerGroup = pg.sprite.GroupSingle(player)

#Img infos vaisseau#
fheart = pg.image.load("graph/fullheart.png").convert_alpha()
fheart = pg.transform.scale(fheart, (50, 50))
eheart = pg.image.load("graph/emptyheart.png").convert_alpha()
eheart = pg.transform.scale(eheart, (50, 50))
############################## Images Menu ##################################
resume_img = pg.image.load("graph/button_resume.png").convert_alpha()
options_img = pg.image.load("graph/button_options.png").convert_alpha()
quit_img = pg.image.load("graph/button_quit.png").convert_alpha()
video_img = pg.image.load("graph/button_video.png").convert_alpha()
audio_img = pg.image.load("graph/button_audio.png").convert_alpha()
keys_img = pg.image.load("graph/button_keys.png").convert_alpha()
back_img = pg.image.load("graph/button_back.png").convert_alpha()
plus_img = pg.image.load("graph/button_plus.png").convert_alpha()
plus_img = pg.transform.scale(plus_img, (50, 50))
minus_img = pg.image.load("graph/button_minus.png").convert_alpha()
minus_img = pg.transform.scale(minus_img, (50, 50))
sound = pg.image.load("graph/sound.png").convert_alpha()
resume_button = Button(304, 125, resume_img, 1)
options_button = Button(297, 250, options_img, 1)
quit_button = Button(336, 375, quit_img, 1)
audio_button = Button(250, 250, audio_img, 1)
video_button = Button(250, 125, video_img, 1)
keys_button = Button(265, 375, keys_img, 1)
back_button = Button(350, 500, back_img, 1)
plus_button = Button(500, 400, plus_img, 1)
minus_button = Button(300, 400, minus_img, 1)



# --- Murs ---
walls = []


############################## création des ennemis ##################################
enemyGroup = fillEnemyGroup(6, 10, WIDTH, SIZE)     # liste contenant tous les ennemis 


############################## Boucle principale ##################################

running = True
while running:
    dt = clock.tick(FPS) / 1000.0               # dt = temps écoulé entre 2 frames, /1000.0 convertit les millisecondes en secondes
    font = pg.font.SysFont("Arial", 24, True)   # police pour affichage texte

    for e in pg.event.get():
        if e.type == pg.QUIT: # On verifie si on quitte le jeu
            running = False

        if game_paused == False:
            if e.type == MISSILE_EVENT:    # Partie de la boucle creation des missiles
                nouvMissile = creationMissile((player.rect.centerx - 4), (player.rect.top - 10), 1, SIZE, "vaisseau") # Creation d'un missile au dessus du joueur
                missilesVaisseau.add(nouvMissile) # Ajout missile dans grp missile
                mixer.music.play()
                score += 1 # +1 score par tir (donc toute les sec)
            if e.type == pg.KEYDOWN:
                if e.key == pg.K_SPACE: # On verifie que la touche "espace" est appuyée pour pauser le jeu
                    game_paused = True
    
    #--- affichages -------------------------------------------------------------
    screen.blit(bg_img, (0, 0))                 # affiche l'image sur la fenêtre graphique aux coordonées (0, 0)        
    enemyGroup.draw(screen)                     # .draw dessine automatiquement tous les sprites de enemyGroup dans screen
    # clamp(WIDTH, HEIGHT, player)                # pose des limites pour rester dans la fenêtre 
                                                                    # for w in walls:
                                                                    # pg.draw.rect(screen, WCOLOR, w)         # affiche les murs (pas de murs pour l'instant)
    playerGroup.draw(screen)                         # affiche le vaisseau
    textScore = font.render(f"Score : {score}", True, (255, 255, 255))   # crée une surface "texte" pour le score
    textPause = font.render("\"ESPACE\" pour mettre pause", True, (255, 255, 255))   # crée une surface "texte" pour indiquer comment pauser, petit rappel : \ permet d'annuler le prochain charactère spécial (ici pour avoir des guillemets)
    textVolume = font.render(f"Volume : {int(optionVolume * 100)}%", True, (255, 255, 255))
    screen.blit(textScore, (650, 10))                # affiche le score en haut à droite
    screen.blit(textPause, (250, 10))               # affiche "PAUSE" en bas à gauche
    missilesVaisseau.draw(screen)               # .draw dessine automatiquement tous les sprites de missilesVaisseau dans screen

    pv_vaisseau(pv_joueur, screen, fheart, eheart, gameover_img) # affiche les pv du vaisseau
    #--- détections des touches du clavier ----------------------------------------
    # k = pg.key.get_pressed()                                            # retourne l'état actuel de toutes les touches du clavier
    # dx = (k[pg.K_RIGHT] or k[pg.K_d]) - (k[pg.K_LEFT] or k[pg.K_q])     # k[pg.K_RIGHT] == 1 si la touche flèche droite est enfoncée sinon vaut 0
    # dy = (k[pg.K_DOWN]  or k[pg.K_s]) - (k[pg.K_UP]   or k[pg.K_z])     # dy vaut +1 vers le bas, -1 vers le haut, 0 sinon
   
    if game_paused == True:
        overlay = pg.Surface((WIDTH, HEIGHT), pg.SRCALPHA) # Crée une surface transparente
        overlay.fill((0, 0, 0, 160)) 
        screen.blit(overlay, (0, 0))

        if menu_state == "main": # Verification de si menu principal est actif
            if resume_button.draw(screen): # Bouton reprendre le jeu
                game_paused = False
            elif options_button.draw(screen): # Bouton option 
                menu_state = "options"      # change au menu "option"
            elif quit_button.draw(screen):    # Bouton qui permet de quitter le jeu
                running = False             # On arrete la boucle principale

        if menu_state == "options": # Verification de si option à été cliqué
            if video_button.draw(screen):
                menu_state = "video"                   # Pass = Placeholder
            elif audio_button.draw(screen):
                menu_state = "audio"    # change au menu "audio"
            elif keys_button.draw(screen):
                menu_state = "keys"
            elif back_button.draw(screen):
                menu_state = "main"

        if menu_state == "video": # Verification de si video à été cliqué
            if back_button.draw(screen):
                menu_state = "options"

        elif menu_state == "audio": # Verification de si audio à été cliqué
            screen.blit(textVolume, (350, 200))
            if minus_button.draw(screen):
                optionVolume -= 0.1
                if optionVolume < 0.0:
                    optionVolume = 0.0
                mixer.music.set_volume(optionVolume)
            if plus_button.draw(screen):
                optionVolume += 0.1
                if optionVolume > 1.0:
                    optionVolume = 1.0
                mixer.music.set_volume(optionVolume)
            if back_button.draw(screen):
                menu_state = "options"
        elif menu_state == "keys": # Verification de si audio à été cliqué
            if back_button.draw(screen):
                menu_state = "options"
        # -------- création d'un missile quand on appuie sur une touche
        # TODO : si telle touche est appuyée alors:
            # missilesVaisseau.add(creationMissile(player.centerx - 5, player.top - 10, 1, int(SIZE / 10), "vaisseau"))
    if game_paused == False:
        #--- déplacements ----------------------------------------
        #move_and_collide(player, dx, dy, SPEED, dt, walls)      # déplacement du vaisseau
        player.update(WIDTH, HEIGHT)
        directionOfEnemies(enemyGroup, WIDTH, SIZE)           # direction des déplacements des ennemis
        enemyGroup.update()                         # déplacement de tous les ennemis
        missilesVaisseau.update()                   # déplacement de tous les missiles

        # Collision entre un missile et un ennemi
        score = detectCollision(missilesVaisseau, enemyGroup, score, SIZE)
        # Collision entre un missile et le vaisseau
        pv_joueur = detectCollision(playerGroup, enemyGroup, pv_joueur, SIZE//2)

    # LOGIQUE
 
    # clamp(WIDTH, HEIGHT, player)

    for w in walls:
        pg.draw.rect(screen, WCOLOR, w)
    pg.display.flip()

    pg.display.update()
pg.quit(); sys.exit()



####################### code en attente ou abandonné pour l'instant ##################################

#--- Défillement du background vers le bas ---
# bg_y += SCROLL_SPEED * dt                       # à chaque frame y augmente
# if bg_y >= bg_height:                           # quand y vaut la valeur de la hauteur de l'image du fond
#     bg_y = 0                                    # y repart à 0 : boucle infinie
# screen.blit(bg_img, (0, bg_y))                  # colle l'image sur la fenêtre graphique aux coordonées (x,y)        
# screen.blit(bg_img, (0, bg_y - bg_height))      # colle l'image juste au-dessous de la première


# --- Murs ---
# walls = []
#     pg.Rect(150, 80, 500, 24),
#     pg.Rect(150, 380, 500, 24),
#     pg.Rect(150, 80, 24, 324),
#     pg.Rect(626, 80, 24, 324),
#     pg.Rect(300, 210, 200, 24),
# ]


